// Generated by CoffeeScript 1.6.3
var EventEmitter, Finder, Heap, distance, fs, gpsStructLength, hashBox, path, stream, unpackGpsInfo, unpackIndex, unpackZoneInfo, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

fs = require('fs');

path = require('path');

Heap = require('heap');

stream = require('stream');

EventEmitter = require('events').EventEmitter;

_ref = require('./util'), unpackZoneInfo = _ref.unpackZoneInfo, unpackIndex = _ref.unpackIndex, gpsStructLength = _ref.gpsStructLength, unpackGpsInfo = _ref.unpackGpsInfo, distance = _ref.distance, hashBox = _ref.hashBox;

Finder = (function(_super) {
  __extends(Finder, _super);

  function Finder(options) {
    var k, length, load, loadFlag, _i, _ref1,
      _this = this;
    this.options = {
      dir: path.join(__dirname, '../data'),
      distance: 'sphere',
      read_info: 'fs',
      max_topn: 100,
      min_index: 3
    };
    for (k in options) {
      if (this.options[k]) {
        this.options[k] = options[k];
      }
    }
    this.distance = distance[this.options.distance];
    this.finfo = JSON.parse(fs.readFileSync(path.join(this.options.dir, 'files.json')));
    this.unpackInfo = unpackZoneInfo["" + this.finfo.packer + "_" + this.options.read_info];
    this.index = [];
    this.indexLength = this.finfo.index.length - 1;
    loadFlag = this.indexLength + 2;
    load = function() {
      if (0 === --loadFlag) {
        return _this.emit('loaded');
      }
    };
    this.on('index_load', load);
    this.on('gps_load', load);
    this.on('zone_load', load);
    this.loadGps().loadZone();
    for (length = _i = 1, _ref1 = this.indexLength; 1 <= _ref1 ? _i <= _ref1 : _i >= _ref1; length = 1 <= _ref1 ? ++_i : --_i) {
      this.loadIndex(length);
    }
  }

  Finder.prototype.loadIndex = function(length) {
    var file,
      _this = this;
    file = path.join(this.options.dir, this.finfo.index[length]);
    fs.readFile(file, function(err, data) {
      var begin, end, hash, index, start, _i, _ref1, _ref2, _ref3;
      if (err) {
        return _this.emit(err);
      }
      index = {};
      for (start = _i = 0, _ref1 = data.length, _ref2 = length + 8; _ref2 > 0 ? _i < _ref1 : _i > _ref1; start = _i += _ref2) {
        _ref3 = unpackIndex(data, length, start), hash = _ref3[0], begin = _ref3[1], end = _ref3[2];
        index[hash] = begin === end ? [begin] : [begin, end];
      }
      _this.index[length] = index;
      data = null;
      _this.emit('index_load', length);
    });
    return this;
  };

  Finder.prototype.loadGps = function() {
    var file,
      _this = this;
    file = path.join(this.options.dir, this.finfo.gps);
    fs.readFile(file, function(err, data) {
      if (err) {
        return _this.emit(err);
      }
      _this.gps = data;
      return _this.emit('gps_load');
    });
    return this;
  };

  Finder.prototype.loadZone = function() {
    var file,
      _this = this;
    file = path.join(this.options.dir, this.finfo.zone);
    if (this.options.read_info === 'fs') {
      fs.open(file, 'r', function(err, zone) {
        _this.zone = zone;
        if (err) {
          return _this.emit(err);
        }
        return _this.emit('zone_load');
      });
    } else {
      fs.readFile(file, function(err, data) {
        if (err) {
          return _this.emit(err);
        }
        _this.zone = data;
        return _this.emit('zone_load');
      });
    }
    return this;
  };

  Finder.prototype.sortList = function(a, b) {
    return a[4] - b[4];
  };

  Finder.prototype.topn = function(lati, long, num, min_index) {
    var heap, i, l, list, z, zone, _i, _j, _k, _l, _len, _len1, _ref1, _ref2;
    if (num == null) {
      num = 3;
    }
    if (min_index == null) {
      min_index = this.options.min_index;
    }
    if (num === 1) {
      if (null === (zone = this.search(lati, long, min_index))) {
        return [];
      }
      return [zone];
    }
    if (num > this.options.max_topn) {
      num = this.options.max_topn;
    }
    if (min_index < 1) {
      min_index = 1;
    }
    list = [];
    i = this.indexLength;
    while (i >= min_index && list.length < num) {
      l = this._searchIndex(lati, long, i--);
      for (_i = 0, _len = l.length; _i < _len; _i++) {
        zone = l[_i];
        list.push(zone);
      }
    }
    heap = new Heap(this.sortList);
    if (num > list.length) {
      num = list.length;
    }
    for (i = _j = 0; 0 <= num ? _j < num : _j > num; i = 0 <= num ? ++_j : --_j) {
      zone = list[i];
      zone[4] = 0 - this.distance(lati, long, zone[0], zone[1]);
      heap.push(zone);
    }
    for (i = _k = num, _ref1 = list.length; num <= _ref1 ? _k < _ref1 : _k > _ref1; i = num <= _ref1 ? ++_k : --_k) {
      zone = list[i];
      zone[4] = 0 - this.distance(lati, long, zone[0], zone[1]);
      if (zone[4] > heap.top()[4]) {
        heap.replace(zone);
      }
    }
    list = [];
    _ref2 = heap.toArray();
    for (_l = 0, _len1 = _ref2.length; _l < _len1; _l++) {
      zone = _ref2[_l];
      z = this.unpackInfo(this.zone, zone[2], zone[3]);
      z.distance = 0 - zone[4];
      list.push(z);
    }
    return list;
  };

  Finder.prototype.search = function(lati, long, min_index) {
    var dist, found, i, list, min, zone, _i, _len;
    if (min_index == null) {
      min_index = this.options.min_index;
    }
    if (min_index < 1) {
      min_index = 1;
    }
    list = [];
    i = this.indexLength;
    while (i >= min_index && list.length === 0) {
      list = this._searchIndex(lati, long, i--);
    }
    found = null;
    switch (list.length) {
      case 0:
        return null;
      case 1:
        found = [list[0][2], list[0][3]];
        min = [this.distance(lati, long, list[0][0], list[0][1])];
        break;
      default:
        min = [999999999, null];
        for (_i = 0, _len = list.length; _i < _len; _i++) {
          zone = list[_i];
          dist = this.distance(lati, long, zone[0], zone[1]);
          if (dist === NaN || dist === 0) {
            found = [zone[2], zone[3]];
            min[0] = 0;
            break;
          }
          if (dist < min[0]) {
            min = [dist, [zone[2], zone[3]]];
          }
        }
        if (!found) {
          found = min[1];
        }
    }
    zone = this.unpackInfo(this.zone, found[0], found[1]);
    zone.distance = min[0];
    return zone;
  };

  Finder.prototype._searchIndex = function(lati, long, length) {
    var box, hash, index, list, offset, poi, _i, _j, _len, _ref1, _ref2;
    box = hashBox(lati, long, length);
    list = [];
    index = this.index[length];
    for (_i = 0, _len = box.length; _i < _len; _i++) {
      hash = box[_i];
      if (poi = index[hash]) {
        if (poi.length === 1) {
          list.push(unpackGpsInfo(this.gps, poi[0]));
        } else {
          for (offset = _j = _ref1 = poi[0], _ref2 = poi[1]; gpsStructLength > 0 ? _j <= _ref2 : _j >= _ref2; offset = _j += gpsStructLength) {
            list.push(unpackGpsInfo(this.gps, offset));
          }
        }
      }
    }
    return list;
  };

  Finder.prototype.close = function() {
    var i, _i, _ref1;
    if (this.options.read_info === 'fs') {
      fs.closeSync(this.zone);
    }
    this.zone = null;
    this.gps = null;
    for (i = _i = 0, _ref1 = this.indexLength; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
      this.index[i] = null;
    }
  };

  return Finder;

})(EventEmitter);

module.exports = function(opt) {
  return new Finder(opt);
};

module.exports.Finder = Finder;
