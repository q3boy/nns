// Generated by CoffeeScript 1.6.3
var Heap, decode, decode_bbox, deg180, deg360, encode, fl, fs, neighbor, radius, zoneInfoBuffer, _ref;

fs = require('fs');

_ref = require('ngeohash'), encode = _ref.encode, neighbor = _ref.neighbor, decode = _ref.decode, decode_bbox = _ref.decode_bbox;

Heap = require('heap');

exports.packZoneInfo = {};

exports.packZoneInfo.bin = function(zone) {
  var buf, field, pos1, pos2, txt, _i, _len, _ref1;
  txt = zone.type + zone.town + zone.county + zone.city + zone.province;
  zone.blen = 21 + Buffer.byteLength(txt);
  buf = new Buffer(zone.blen);
  buf.writeUInt32BE(zone.id, 0);
  buf.writeUInt32BE((0.5 + zone.lati * 1000000) | 0, 4);
  buf.writeUInt32BE((0.5 + zone.long * 1000000) | 0, 8);
  buf.writeUInt32BE(zone.pnum, 12);
  pos1 = 16;
  pos2 = 21;
  _ref1 = ['type', 'town', 'county', 'city', 'province'];
  for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
    field = _ref1[_i];
    if (!((txt = zone[field]) instanceof Buffer)) {
      txt = new Buffer(txt);
    }
    buf.writeUInt8(txt.length, pos1++);
    txt.copy(buf, pos2);
    pos2 += txt.length;
  }
  return buf;
};

exports.packZoneInfo.json = function(zone) {
  var buf, k, nzone;
  nzone = {};
  for (k in zone) {
    if (k !== 'offset' && k !== 'hash' && k !== 'blen') {
      nzone[k] = zone[k];
    }
  }
  buf = new Buffer(JSON.stringify(nzone));
  zone.blen = buf.length;
  return buf;
};

exports.unpackZoneInfo = {};

exports.unpackZoneInfo.bin_buffer = function(buf, start) {
  var offset;
  offset = 21;
  return {
    id: buf.readUInt32BE(start + 0, true),
    lati: buf.readUInt32BE(start + 4, true) / 1000000,
    long: buf.readUInt32BE(start + 8, true) / 1000000,
    pnum: buf.readUInt32BE(start + 12, true),
    type: buf.slice(offset, offset += buf.readUInt8(start + 16, true)),
    town: buf.slice(offset, offset += buf.readUInt8(start + 17, true)),
    county: buf.slice(offset, offset += buf.readUInt8(start + 18, true)),
    city: buf.slice(offset, offset += buf.readUInt8(start + 19, true)),
    province: buf.slice(offset, offset += buf.readUInt8(start + 20, true))
  };
};

zoneInfoBuffer = new Buffer(65536);

exports.unpackZoneInfo.bin_fs = function(fd, offset, length) {
  fs.readSync(fd, zoneInfoBuffer, 0, length, offset);
  offset = 21;
  return {
    id: zoneInfoBuffer.readUInt32BE(0, true),
    lati: zoneInfoBuffer.readUInt32BE(4, true) / 1000000,
    long: zoneInfoBuffer.readUInt32BE(8, true) / 1000000,
    pnum: zoneInfoBuffer.readUInt32BE(12, true),
    type: zoneInfoBuffer.slice(offset, offset += zoneInfoBuffer.readUInt8(16, true)),
    town: zoneInfoBuffer.slice(offset, offset += zoneInfoBuffer.readUInt8(17, true)),
    county: zoneInfoBuffer.slice(offset, offset += zoneInfoBuffer.readUInt8(18, true)),
    city: zoneInfoBuffer.slice(offset, offset += zoneInfoBuffer.readUInt8(19, true)),
    province: zoneInfoBuffer.slice(offset, offset += zoneInfoBuffer.readUInt8(20, true))
  };
};

exports.unpackZoneInfo.json_buffer = function(buf, offset, length) {
  return JSON.parse(buf.toString('utf8', offset, offset + length));
};

exports.unpackZoneInfo.json_fs = function(fd, offset, length) {
  fs.readSync(fd, zoneInfoBuffer, 0, length, offset);
  return JSON.parse(zoneInfoBuffer.toString('utf8', 0, length));
};

exports.gpsStructLength = 14;

exports.packGpsInfo = function(zone) {
  var buf;
  buf = new Buffer(14);
  buf.writeUInt32BE((0.5 + zone.lati * 1000000) | 0, 0);
  buf.writeUInt32BE((0.5 + zone.long * 1000000) | 0, 4);
  buf.writeUInt32BE(zone.offset, 8);
  buf.writeUInt16BE(zone.blen, 12);
  return buf;
};

exports.unpackGpsInfo = function(buf, start) {
  return [buf.readUInt32BE(start, true) / 1000000, buf.readUInt32BE(start + 4, true) / 1000000, buf.readUInt32BE(start + 8, true), buf.readUInt16BE(start + 12, true)];
};

exports.packIndex = function(hash, begin, end) {
  var buf, length;
  buf = new Buffer((length = hash.length) + 8);
  buf.write(hash, 0);
  buf.writeUInt32BE(begin * exports.gpsStructLength, length);
  buf.writeUInt32BE(end * exports.gpsStructLength, length + 4);
  return buf;
};

exports.unpackIndex = function(buf, length, start) {
  var pos;
  return [buf.toString('utf8', start, pos = start + length), buf.readUInt32BE(pos), buf.readUInt32BE(pos + 4)];
};

radius = 6378137.0;

deg180 = Math.PI / 180.0;

deg360 = Math.PI / 360;

fl = 1 / 298.257;

exports.distance = {
  sphere: function(alati, along, blati, blong) {
    var flat, flng, result, tlat, tlng;
    flat = alati * deg180;
    flng = along * deg180;
    tlat = blati * deg180;
    tlng = blong * deg180;
    result = Math.sin(flat) * Math.sin(tlat) + Math.cos(flat) * Math.cos(tlat) * Math.cos(flng - tlng);
    return Math.acos(result) * radius;
  },
  ellipsoid: function(alati, along, blati, blong) {
    var c, d, h1, h2, r, s, sf, sg, sl, w;
    sg = Math.sin(deg360 * (alati - blati));
    sl = Math.sin(deg360 * (along + blong));
    sf = Math.sin(deg360 * (alati + blati));
    sg *= sg;
    sl *= sl;
    sf *= sf;
    s = sg * (1 - sl) + (1 - sf) * sl;
    c = (1 - sg) * (1 - sl) + sf * sl;
    w = Math.atan(Math.sqrt(s / c));
    r = Math.sqrt(s * c) / w;
    h1 = (3 * r - 1) / 2 / c;
    h2 = (3 * r + 1) / 2 / s;
    d = 2 * w * radius;
    return d * (1 + fl * (h1 * sf * (1 - sg) - h2 * (1 - sf) * sg));
  }
};

exports.hashBox = function(lati, long, length) {
  var hash;
  hash = encode(lati, long, length);
  return [hash, neighbor(hash, [1, 0]), neighbor(hash, [-1, 0]), neighbor(hash, [0, 1]), neighbor(hash, [0, -1]), neighbor(hash, [1, 1]), neighbor(hash, [1, -1]), neighbor(hash, [-1, 1]), neighbor(hash, [-1, -1])];
};

exports.parseLineText = function(line) {
  var city, county, hash, id, lati, list, long, p, pnum, pos, province, town, txt, type, zone, _i, _len, _ref1, _ref2, _ref3, _ref4;
  _ref1 = line.split(/\t+/g), id = _ref1[0], txt = _ref1[1];
  id *= 1;
  _ref2 = txt.split(';'), zone = _ref2[0], type = _ref2[1], pos = _ref2[2], pnum = _ref2[3];
  pos = pos.split(',');
  pnum *= 1;
  _ref3 = zone.split(' '), province = _ref3[0], city = _ref3[1], county = _ref3[2], town = _ref3[3];
  list = [];
  for (_i = 0, _len = pos.length; _i < _len; _i++) {
    p = pos[_i];
    if (!(p !== '')) {
      continue;
    }
    _ref4 = p.split(':'), lati = _ref4[0], long = _ref4[1];
    lati *= 1;
    long *= 1;
    hash = encode(lati, long, 12);
    list.push({
      id: id,
      hash: hash,
      lati: lati,
      long: long,
      type: type,
      pnum: pnum,
      town: town,
      county: county,
      city: city,
      province: province
    });
  }
  return list;
};
